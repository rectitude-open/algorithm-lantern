---
title: Complexity
description: Complexity
slug: /complexity
sidebar_position: 3
---

### 要复杂度干什么

- 算法，离不开数据，这是基础，不能忘掉。
- 而算法的好坏，需要一种衡量标准，最好有一种直观的数学描述，复杂度就是干这个的。
- 从维度上说，我们考虑到算法在两个方向上的成本：
  - 时间上：能不能尽量的快 -> 也就是运行速度
  - 空间上：能不能尽量的省 -> 也说是内存占用
- 结合以上，以数据规模为底，衡量某种算法的时间和空间，就有了这样的标准：
  - 时间复杂度：随着数据量越来越大，时间消耗是怎么样，是越来越慢，还是越来越快？
  - 空间复杂度：随着数据量越来越大，内存占用是怎么样，是越来越多，还是越来越少？
- 这里必须明确，复杂度不是一个确定的值，而是跟数据规模有关的一个变化的量，是一种趋势的表达。
- 在数学中，我们学过函数；在程序开发中，也每天都写函数。函数这个东西，恰恰就是描述关系，描述趋势，描述规律的。
- 在这里，我们为了清晰的表达复杂度，数学上使用大写的 O 这个符号，来描述函数的集合，也就是复杂度的集合。
- 为啥是复杂度的集合而不是复杂度呢？因为我们一般只描述最坏的情况，表达的是集合的上限，这个可以不完全理解，后面会有体会。

### 复杂度的表达

- **O(1)**
  - 这种表示，一般叫常数/常量复杂度。
  - 注意，这个 1 啊，我们说了，复杂度可不是一个固定的值，所以，不是说某个算法只用 1 毫秒或是只用 1 bit 内存。
  - O 括号里的表示，永远是一种趋势的表达，不是具体的表达。所以这里的 1，也是一种趋势的表达，不是真的值为 “1”。
  - n 永远代表数据规模，如果你在括号里没看见 n，那说明这个算法的时间和空间消耗，跟数据规模无关。O(1) 就是这样的。
  - 只要算法与数据规模无关，就用 O(1) 表示。
  - 一个复杂度为 O(1) 的算法，它的运行时间可能是 1 毫秒，也可能是 16 天，无轮数据规模多大，它的运行时间都是固定的。
  - 那为什么不用 0，不用 888，不用 999 而是用 1 呢？因为人家数学家认为，1 是最小的常数，用它表达最简单。
  - 所以我们总结一下，O(1) 表示，无论数据规模多大，算法的时间/空间消耗都是固定的，不随数据规模而变化。
  - 那你问了，说不随数据规模变化，那到底是多快呢，到底占用多少呢？这个不用管，既然不随数据规模变化，说明占用是固定的。也就是：极快，占用极少。
  - 从这里你也看出，复杂度，真的是与数据规模 n 相关。
  - 所以 O(1) ，是常数级别的复杂度，是理论上最理想的复杂度。
  - 插一嘴，常数是很好，但如果常数太大，比如一万年，或者一万 TB，那也完蛋了，所以这是理论上最高效的复杂度，而实际上，还得结合具体常数来衡量。
  - 下面举例几个 O(1) 的情况
    - 比如我们编程语言中的数组访问，我们通过下标 `array[8823129]`, 这个操作，不管数组有多大，访问时间都是固定的，所以是 O(1)。
    - 比如我们在听一首歌，虽然列表里有 1000 万条歌曲，但当我们点暂停时，不会因为歌曲多就暂停慢，这是因为暂停操作是 O(1) 的。

### 时间复杂度

- 关注**操作次数**随着**数据规模增长**的**变化趋势**。
- 计算机的算力有限，操作次数就等于时间，所以它决定了算法适合处理的数据规模。
- 越少的操作次数，意味着更好的效率。
- 细节上说，关注循环/递归次数和每轮操作的代价。

### 空间复杂度

- 关注运行过程中消耗的**内存空间**与**数据规模**的**关系**。
- 计算资源有限，如果空间无限增长会肯定导致崩溃。
- 除本身数据量以外，算法在处理时其他的内存占用越少越好，如果成倍增加就完蛋。
- 这里注意，空间复杂度忽略数据本身的空间占用，只关注额外的空间占用。
- 细节上说，关注栈空间、临时变量等，别忘了隐式的内存占用。

### 二分查找的复杂度

- 时间复杂度：O(logN)
  - 每次比较，问题规模减半，相当于对数据量 n 取对数。
  - 100 条数据最多 7 次比较 (2^7=128)
  - 100 万条数据最多 20 次比较 (2^20=1048576)
- 空间复杂度：O(1)
  - 仅维护三个变量，不随数据量变化，无需额外存储。

### 复杂度的妙用

- 时间和空间是一种权衡，有时候用时间换空间，有时候用空间换时间。
- 时间换空间：布隆过滤器（Bloom Filter）用少量误判率换取 O(1) 的查询时间和极低内存占用，适合海量数据去重。
- 空间换时间：数据库索引通过预计算建立 B+ 树（占用额外存储空间），将查询从 O(n) 优化到 O(log n)。
