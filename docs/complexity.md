---
title: Complexity
description: Complexity
slug: /complexity
sidebar_position: 3
---

### 要复杂度干什么

- 算法，离不开数据，这是基础，不能忘掉。
- 而算法的好坏，需要一种衡量标准，最好有一种直观的数学描述，复杂度就是干这个的。
- 从维度上说，我们考虑到算法在两个方向上的成本：
  - 时间上：能不能尽量的快 -> 也就是运行速度
  - 空间上：能不能尽量的省 -> 也说是内存占用
- 结合以上，以数据规模为底，衡量某种算法的时间和空间，就有了这样的标准：
  - 时间复杂度：随着数据量越来越大，时间消耗是怎么样，是越来越慢，还是越来越快？
  - 空间复杂度：随着数据量越来越大，内存占用是怎么样，是越来越多，还是越来越少？
- 这里必须明确，**复杂度不是一个固定的值**，而是跟数据规模有关的一个变化的量，是一种**趋势**的表达。
- 在数学中，我们学过函数；在程序开发中，也每天都写函数。函数这个东西，恰恰就是描述关系，描述趋势，描述规律的。
- 在这里，我们为了清晰的表达复杂度，数学上使用大写的 **O** 这个符号，来描述函数的集合，也就是所有这种**趋势的集合**。

### 复杂度的表达

- **O(1)**

  - 这种表示，一般叫常数/常量复杂度。
  - 注意，这个 1 啊，我们说了，复杂度可不是一个固定的值，所以，O(1) 不是说某个算法只用 1 毫秒或是只用 1 bit 内存。
  - O 括号里的表示，永远是一种趋势的表达，不是具体的表达。所以这里的 1，也是一种趋势的表达，不是真的说值为 “1”。
  - 我们之前说道过，算法永远与数据规模有关，我们用 n 来代表数据的规模。
  - 如果你在括号里没看见 n，那说明这个算法的时间或空间消耗，跟数据规模无关。O(1) 就是这样。
  - 只要算法与数据规模无关，就用 O(1) 表示。
  - 一个复杂度为 O(1) 的算法，它的运行时间可能是 1 毫秒，也可能是 16 天，无轮数据规模多大，它的运行时间都是固定的。
  - 那为什么不用 0，不用 16，不用 999 而是用 1 呢？因为人家数学家认为，1 是最小的常数，用它表达最简单。
  - 所以我们总结一下，**O(1)意味着，无论数据规模多大，算法的时间/空间消耗都是固定的，不随数据规模而变化**。
  - 那你问了，说不随数据规模变化，那到底是多快呢，到底占用多少呢？这个不用管，既然不随数据规模变化，说明占用是固定的。也就是：极快，占用极少。
  - 从这里你能看出，复杂度这个东西，真的是强调它与数据规模之间的关系。
  - 所以 O(1) ，是常数级别的复杂度，是理论上最理想的复杂度。
  - 插一嘴，常数是很好，但如果常数太大，比如一万年，或者一万 TB，那也完蛋了，所以这是理论上最高效的复杂度，而实际上，还得结合具体常数来衡量。
  - 下面举例几个 O(1) 的情况
    - 比如我们编程语言中的数组访问，我们通过下标 `array[12345]`, 这个操作，不管数组有多大，访问时间都是固定的，所以是 O(1)。
    - 比如我们在听一首歌，虽然列表里有 1000 万条歌曲，但当我们点暂停时，不会因为歌曲多就暂停慢，这是因为暂停操作是 O(1) 的。

- **O(n)**

  - 一眼能看出，这里跟数据规模有关了。那具体有什么关系呢？
  - 就是说，随着数据规模 n 的增大，算法的时间/空间消耗，是线性增长的。
  - 所谓线性，可以理解为，数据规模增加 1，算法的时间/空间消耗也增加 1。
  - 常见的例子，一个数组，长度是 n。我们现在要遍历这个数组，那肯定要一个一个读啊，数组多大就读多大，那么遍历的时间就是 O(n)。
  - 但是别误会，它并不是说，数据规模是 n，它也是 n。再次注意，这是趋势，不是固定的值。往下看就明白了。

- **O(365n)**
  - 一眼能看出，它是数据规模的 365 倍，那就不对了。说过很多次，要趋势，不要确切的值。
  - 我们描述复杂度，想表达它与数据规模的关系，表达趋势，而 365 不是趋势，是值了，是非常确定的 365 倍。
  - 所以，这种写法是不对的。即使真的是 365 倍的关系，我们也写 O(n)，这才能是趋势的表达。
  - 所以再回头想，O 的表达，不是一个函数。一个函数只表达一种关系，比如 y = 365x。
  - 而 O 是归纳这些函数的特征，形成函数的集合，就变成了一种趋势的表达。
  - 哎，但你会有疑问。如果一个算法是 2n，另一个是 365n，那差异可很大啊，不表达出来是不是太二了？
  - 这是一种角度问题，前面 2 或是 365 ，我们叫常数。常数不是不重要，只是在复杂度的表达上，它不关注。
  - 算法尤其关注大数据，所以复杂度的**格局很大**，它想对比的是**碾压级别**的差异，常数只是小儿科。
  - 而且，另一个现实的问题，想准确算出常数，也不太容易。所以这类似于程序设计中的抽象，不关注细节。

### 时间复杂度

- 关注**操作次数**随着**数据规模增长**的**变化趋势**。
- 计算机的算力有限，操作次数就等于时间，所以它决定了算法适合处理的数据规模。
- 越少的操作次数，意味着更好的效率。
- 细节上说，关注循环/递归次数和每轮操作的代价。

### 空间复杂度

- 关注运行过程中消耗的**内存空间**与**数据规模**的**关系**。
- 计算资源有限，如果空间无限增长会肯定导致崩溃。
- 除本身数据量以外，算法在处理时其他的内存占用越少越好，如果成倍增加就完蛋。
- 这里注意，空间复杂度忽略数据本身的空间占用，只关注额外的空间占用。
- 细节上说，关注栈空间、临时变量等，别忘了隐式的内存占用。

### 二分查找的复杂度

- 时间复杂度：O(logN)
  - 每次比较，问题规模减半，相当于对数据量 n 取对数。
  - 100 条数据最多 7 次比较 (2^7=128)
  - 100 万条数据最多 20 次比较 (2^20=1048576)
- 空间复杂度：O(1)
  - 仅维护三个变量，不随数据量变化，无需额外存储。

### 复杂度的妙用

- 时间和空间是一种权衡，有时候用时间换空间，有时候用空间换时间。
- 时间换空间：布隆过滤器（Bloom Filter）用少量误判率换取 O(1) 的查询时间和极低内存占用，适合海量数据去重。
- 空间换时间：数据库索引通过预计算建立 B+ 树（占用额外存储空间），将查询从 O(n) 优化到 O(log n)。
