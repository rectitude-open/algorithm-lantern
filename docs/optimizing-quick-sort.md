---
title: Optimizing Quick Sort
description: Optimizing Quick Sort
slug: /optimizing-quick-sort
sidebar_position: 4
---

### 朴素快排中内存爆炸的根源

- 递归时，每层几乎都要存储 n 个元素副本
- 基准选择不当，导致分区不平衡
- 每层递归都要创建 low/high/equal 三个数组

### 核心优化思路

- 随机化基准选择
- 模拟栈，递归改迭代
- 原地分区，不另外创建数组

### 用栈+迭代来模拟递归的逻辑

- 递归是不断的调用自己，直到满足某个条件。另外，系统会自动对当前迭代的状态进行保存。
  - 所以它有三个关键：循环执行+停止条件+自动状态保存。
- 对于循环，我们用循环+栈来代替。用数组模拟一个栈，不断的压入数据，然后循环执行弹出，直到栈为空。
- 对于停止条件，我们后续再研究怎么写这个逻辑，但必须先明确它的主要目的是不再压入栈，也就会导致栈最终为空。
- 对于状态，也属于业务逻辑范畴，我们后续讨论到底要维护哪些状态。

有了一个基本逻辑，我们能描绘出这个迭代函数的大致轮廓：

```php
$stack = [1,2,3,4]          # 用数组模拟栈，里面放什么再讨论，这里模拟了4个数字
while(!empty($stack)) {   # 直到栈为空，不再循环
  // [停止条件]             # 后续讨论，它的作用是不再压入栈
  array_pop($stack);      # 弹出栈顶元素，它是有用的
  // [执行的算法逻辑]       # 后续讨论，这里应该是算法的核心逻辑
  array_push($stack,[5])    # 压入新的数据，后续讨论，它的作用是继续循环，这里模拟压入了数字5
}

```

### 迭代函数的逻辑

- 循环用 while，停止条件是空栈。
- 这个函数要处理的业务：首先要模拟一个栈，其次，要协调分区函数，不断地把要处理的区域地址压入栈中。
- 栈中存储的是每次要处理的数组的下标范围，只要两个整数就够了，一个叫 `low`，一个叫 `high`
- 默认的话，栈中只有一个元素，就是整个数组的下标范围 `[0, len(arr)-1]`
- 进入栈中，先弹出栈顶元素，然后判断是否需要处理，如果不需要，直接跳过。
- 明确，如果 `low` 比 `high` 大，意味着这个区域已经没有元素了，直接跳过，不要再压入栈了。
- 否则，就调用分区函数，分区函数会返回基准值的位置，然后把左右两个区域的下标范围压入栈中。
- 这样，下一次循环，就会处理这两个区域，直到栈为空。
- 自己压栈，自己弹栈，自己执行，自己判断停止条件，这就模拟了递归的过程。

### 分区函数的逻辑

- 先明确这个函数的目的，有两个：
  - 一是将数组分成两个区域，一个是小于基准值的，一个是大于基准值的。
  - 二是找到基准值的位置，也就是 `pivot` 的位置，并最终返回这个位置。
- 随机选出一个位置 `randomIndex`，将这个位置的值作为基准值。
- 基准值先扔在最后一个位置，这样它就是 `highest` 下标，既好记，又好用。所以先做一次交换。
  `randomIndex <-> highest`
- 现在明确，我们的基准值在最后一个位置上，也就是 `highest` 位置的值。
- 下一步，我们依然要区分出两个区域，这依然是快排算法的精髓。只是这次，我们不再创建两个数组了，而是直接在原数组上操作，想像成数组是一条直线上的多个端点。
- `low` 区域和 `high` 区域可以通过一个 `lowLast` 游标来切分，它是 `low` 区域的最大的下标，可以表示成这样：`[0, lowLast], 基准, [lowLast+2, highest]`
- 通过循环，判断当前元素与基准值谁大谁小，如果小于基准值，就把 `lowLast` 右移一位，相当于扩大了 `low` 区域，然后把当前元素与 `lowLast` 交换。
- 这相当于是根据实际情况，不断的扩充了 `low` 区域，而保持 `low` 区域都是小于基准的，而且最大下标就是 `lowLast`。
- 最后，我们知道基准值其实应该在中间，而开头我们把它扔到了最后，现在要换回来。那恰好 `lowest + 1` 就是应该是基准值的位置，所以把它与 `highest` 交换即可。

### 差异解释

#### 随机化基准选择

- 原代码中，总是使用第一个元素作为基准，极端情况下，时间复杂度退化为 O(n²)，如 [1,2,3,4,5,6]。
- 优化后，每次随机选择一个元素作为基准，避免最坏时间复杂度。

#### 递归与迭代

- 原代码中，使用递归，系统会自动维护一个栈，用于存储调用的上下文（参数变量返回地址等）。
- 优化后，通过数组模拟栈，手动维护了两个整数 `low` 和 `high`，节省内存开销。

#### 额外数组与原地分区

- 原代码中，每次递归都会创建三个数组，然后复制数据、拼接数据。
- 原地分区（In-place Partition）：内存消耗不会随着数据量增加而增加，空间复杂度为 O(1)。
- 优化后，所有交换操作都直接基于原数组，只额外存储了位置信息，不会创建额外的数组，也避免了复制和拼接。

### 递归与迭代

#### 递归

- 递归每次递归系统会自动将当前状态压入栈，内存管理由系统自动完成。
- 递归代码简洁，符合人类思维，直观，可读性强。
- 内存不可控，递归深度过深会导致栈溢出。
- 属于懒人分治。

#### 迭代

- 迭代是利用循环和数据结构，显式地控制流程和维护状态。
- 迭代代码相对复杂，需要手动维护状态，可读性差。
- 内存可控，适合处理大数据。
- 属于勤人分治。

### 递归转迭代

大多数递归算法都可以转换为迭代。

- 用栈或队列模拟递归调用过程，存储待处理的子任务。
- 用循环替代递归，不断取出栈中的任务，直到栈为空。
- 对于递归参数，手动定义变量维护状态。
